var IexecOracle = artifacts.require("./IexecOracle.sol");
var IexecOracleAPI = artifacts.require("./IexecOracleAPITest.sol");
var IexecOracleEscrow = artifacts.require("./IexecOracleEscrow.sol");
var IexecOracleAPIUnregistered = artifacts.require("./IexecOracleAPIUnregistered.sol");
var RLC = artifacts.require("../node_modules/rlc-token//contracts/RLC.sol");


const Promise = require("bluebird");
//extensions.js : credit to : https://github.com/coldice/dbh-b9lab-hackathon/blob/development/truffle/utils/extensions.js
const Extensions = require("../utils/extensions.js");
const addEvmFunctions = require("../utils/evmFunctions.js");
addEvmFunctions(web3);
Promise.promisifyAll(web3.eth, {
  suffix: "Promise"
});
Promise.promisifyAll(web3.version, {
  suffix: "Promise"
});
Promise.promisifyAll(web3.evm, {
  suffix: "Promise"
});
Extensions.init(web3, assert);


contract('IexecOracleAPI', function(accounts) {

  var provider, bridge, user, rlcCreator;
  var amountGazProvided = 4000000;
  let isTestRPC;
  let testTimemout = 0;
  let aRLCInstance;
  let aIexecOracleEscrowInstance;

  IexecOracle.Status = {
    UNSET: 0,
    UNAVAILABLE: 1,
    PENDING: 2,
    RUNNING: 3,
    COMPLETED: 4,
    ERROR: 5
  };

  before("should prepare accounts and check TestRPC Mode", function() {
    assert.isAtLeast(accounts.length, 4, "should have at least 4 accounts");
    provider = accounts[0];
    bridge = accounts[1];
    user = accounts[2];
    rlcCreator = accounts[3];

    return Extensions.makeSureAreUnlocked(
        [provider, bridge, user])
      .then(() => web3.eth.getBalancePromise(provider))
      .then(balance => assert.isTrue(
        web3.toWei(web3.toBigNumber(90), "ether").lessThan(balance),
        "provider should have at least 35 ether, not " + web3.fromWei(balance, "ether")))
      .then(() => Extensions.refillAccount(provider, user, 10))
      .then(() => Extensions.refillAccount(provider, bridge, 10))
      .then(() => Extensions.refillAccount(provider, rlcCreator, 10))
      .then(() => web3.version.getNodePromise())
      .then(node => isTestRPC = node.indexOf("EthereumJS TestRPC") >= 0)
      .then(() => {
        return RLC.new({
          from: rlcCreator,
          gas: amountGazProvided
        });
      })
      .then(instance => {
        aRLCInstance = instance;
        return aRLCInstance.unlock({
          from: rlcCreator,
          gas: amountGazProvided
        });
      })
      .then(txMined => {
        assert.isBelow(txMined.receipt.gasUsed, amountGazProvided, "should not use all gas");
        return IexecOracleEscrow.new(aRLCInstance.address, {
          from: bridge
        });
      })
      .then(instance => {
        aIexecOracleEscrowInstance = instance;
      });
  });

  it("Test call registerDappAndProvider with tx.origin = msg.sender", function() {
    return IexecOracle.new(aIexecOracleEscrowInstance.address, 0, {
        from: bridge
      })
      .then(instance => {
        aIexecOracleInstance = instance;
        return Extensions.expectedExceptionPromise(() => {
            return aIexecOracleInstance.registerDappAndProvider(0, "aDappName", {
              from: provider,
              gas: amountGazProvided
            });
          },
          amountGazProvided);
      });
  });

  it("Test owner can change aIexecOracleEscrowInstance registration", function() {
    return IexecOracle.new(aIexecOracleEscrowInstance.address, 0, {
        from: bridge
      })
      .then(instance => {
        aIexecOracleInstance = instance;
        return aIexecOracleEscrowInstance.isIexecOracleRegistered.call(aIexecOracleInstance.address);
      })
      .then(isIexecOracleRegistered => {
        assert.isFalse(isIexecOracleRegistered, "aIexecOracleInstance not yet registered");
        return aIexecOracleEscrowInstance.changeIexecOracleRegistrationStatus(aIexecOracleInstance.address, true, {
          from: bridge
        });
      })
      .then(txMined => {
        assert.isBelow(txMined.receipt.gasUsed, amountGazProvided, "should not use all gas");
        return aIexecOracleEscrowInstance.isIexecOracleRegistered.call(aIexecOracleInstance.address);
      })
      .then(isIexecOracleRegistered => {
        assert.isTrue(isIexecOracleRegistered, "aIexecOracleInstance must be registered");
      });
  });


  it("Test user can't change aIexecOracleEscrowInstance registration", function() {
    return IexecOracle.new(aIexecOracleEscrowInstance.address, 0, {
        from: bridge
      })
      .then(instance => {
        aIexecOracleInstance = instance;
        return aIexecOracleEscrowInstance.isIexecOracleRegistered.call(aIexecOracleInstance.address);
      })
      .then(isIexecOracleRegistered => {
        assert.isFalse(isIexecOracleRegistered, "aIexecOracleInstance not yet registered");
        return aIexecOracleEscrowInstance.changeIexecOracleRegistrationStatus(aIexecOracleInstance.address, true, {
          from: user
        });
      })
      .then(txMined => {
        assert.isBelow(txMined.receipt.gasUsed, amountGazProvided, "should not use all gas");
        return aIexecOracleEscrowInstance.isIexecOracleRegistered.call(aIexecOracleInstance.address);
      })
      .then(isIexecOracleRegistered => {
        assert.isFalse(isIexecOracleRegistered, "user can't register an address");
      });
  });


  it("Test emergencyERC20Drain in IexecOralce call by owner", function() {
    return IexecOracle.new(aIexecOracleEscrowInstance.address, 0, {
        from: bridge
      })
      .then(instance => {
        aIexecOracleInstance = instance;
        return aRLCInstance.transfer(aIexecOracleInstance.address, 2, {
          from: rlcCreator,
          gas: amountGazProvided
        });
      })
      .then(txMined => {
        assert.isBelow(txMined.receipt.gasUsed, amountGazProvided, "should not use all gas");
        return aRLCInstance.balanceOf(aIexecOracleInstance.address);
      })
      .then(balance => {
        assert.strictEqual(2, balance.toNumber(), " 2 RLC locked in aIexecOracleInstance .. ");
        return aIexecOracleInstance.emergencyERC20Drain(aRLCInstance.address, 2, {
          from: bridge,
          gas: amountGazProvided
        });
      })
      .then(txMined => {
        assert.isBelow(txMined.receipt.gasUsed, amountGazProvided, "should not use all gas");
        return aRLCInstance.balanceOf(aIexecOracleInstance.address);
      })
      .then(balance => {
        assert.strictEqual(0, balance.toNumber(), " RLC have been removed from aIexecOracleInstance .. ");
      });
  });

  it("Test emergencyERC20Drain in IexecOralce call by a user", function() {
    return IexecOracle.new(aIexecOracleEscrowInstance.address, 0, {
        from: bridge
      })
      .then(instance => {
        aIexecOracleInstance = instance;
        return aRLCInstance.transfer(aIexecOracleInstance.address, 2, {
          from: rlcCreator,
          gas: amountGazProvided
        });
      })
      .then(txMined => {
        assert.isBelow(txMined.receipt.gasUsed, amountGazProvided, "should not use all gas");
        return aRLCInstance.balanceOf(aIexecOracleInstance.address);
      })
      .then(balance => {
        assert.strictEqual(2, balance.toNumber(), " 2 RLC locked in aIexecOracleInstance .. ");
        return aIexecOracleInstance.emergencyERC20Drain(aRLCInstance.address, 2, {
          from: user,
          gas: amountGazProvided
        });
      })
      .then(txMined => {
        assert.isBelow(txMined.receipt.gasUsed, amountGazProvided, "should not use all gas");
        return aRLCInstance.balanceOf(aIexecOracleInstance.address);
      })
      .then(balance => {
        assert.strictEqual(2, balance.toNumber(), "2 RLC still locked in aIexecOracleInstance  ");
      });
  });


  describe("Test provider, dapp free registration In IexecOracle", function() {
    let aIexecOracleInstance;
    let aIexecOracleAPI;
    let aRLCInstance;
    let aIexecOracleEscrowInstance;
    let previousBlockNumber
    beforeEach("create a new contract instance", function() {
      return RLC.new({
          from: rlcCreator,
          gas: amountGazProvided
        })
        .then(instance => {
          aRLCInstance = instance;
          return aRLCInstance.unlock({
            from: rlcCreator,
            gas: amountGazProvided
          });
        })
        .then(txMined => {
          assert.isBelow(txMined.receipt.gasUsed, amountGazProvided, "should not use all gas");
          return IexecOracleEscrow.new(aRLCInstance.address, {
            from: bridge
          });
        })
        .then(instance => {
          aIexecOracleEscrowInstance = instance;
          return IexecOracle.new(aIexecOracleEscrowInstance.address, 0, {
            from: bridge
          });
        })
        .then(instance => {
          aIexecOracleInstance = instance;
          return Extensions.getCurrentBlockNumber();
        })
        .then(block => {
          previousBlockNumber = block;
          return IexecOracleAPI.new(aIexecOracleInstance.address, 0, "aDappName", {
            from: provider
          });
        })
        .then(instance => {
          aIexecOracleAPI = instance;
        });
    });

    it("Test provider and dapp of IexecOracleAPI are set correctly in IexecOracle", function() {
      this.timeout(testTimemout);
      return aIexecOracleInstance.getProvider.call(aIexecOracleAPI.address)
        .then(providerStored => {
          assert.strictEqual(provider, providerStored, "provider check");
        });
    });

    it("Test dapp price are set correctly in IexecOracle", function() {
      this.timeout(testTimemout);
      return aIexecOracleInstance.getDappPrice.call(aIexecOracleAPI.address)
        .then(priceStored => {
          assert.strictEqual(0, priceStored.toNumber(), "0 priceStored");
        });
    });

    it("Test dapp name are set correctly in IexecOracle", function() {
      this.timeout(testTimemout);
      return aIexecOracleInstance.getDappName.call(aIexecOracleAPI.address)
        .then(dappStored => {
          assert.strictEqual("aDappName", dappStored.toString(10), "dappStored");
        });
    });

    it("Test getDapp in IexecOracle", function() {
      this.timeout(testTimemout);
      return aIexecOracleInstance.getDapp.call(aIexecOracleAPI.address)
        .then(dapp => {
          [nameStored, priceStored, providerStored] = dapp;
          assert.strictEqual("aDappName", nameStored.toString(10), "aDappName");
          assert.strictEqual(0, priceStored.toNumber(), "0 priceStored");
          assert.strictEqual(provider, providerStored, "provider check");
        });
    });

    it("Test Resgister event with and provider and dapp", function() {
      this.timeout(testTimemout);
      return Extensions.getEventsPromise(aIexecOracleInstance.Register({}, {
          fromBlock: previousBlockNumber
        }))
        .then(events => {
          assert.strictEqual(events[0].args.dapp, aIexecOracleAPI.address, "dapp");
          assert.strictEqual(events[0].args.provider, provider, "provider");
          assert.strictEqual(events[0].args.dappPrice.toNumber(), 0, "dappPrice");
        });
    });

    it("Cannot change provider in aIexecOracleInstance after first call by IexecOracleAPI constructor", function() {
      this.timeout(testTimemout);
      return Extensions.expectedExceptionPromise(() => {
          return aIexecOracleAPI.impossible(aIexecOracleInstance.address, {
            from: user,
            gas: amountGazProvided
          });
        },
        amountGazProvided);
    });

  });

  describe("Test provider, dapp (1 RLC cost) registration In IexecOracle", function() {
    let aIexecOracleInstance;
    let aIexecOracleAPI;
    let aRLCInstance;
    let aIexecOracleEscrowInstance;
    let previousBlockNumber
    beforeEach("create a new contract instance", function() {
      return RLC.new({
          from: rlcCreator,
          gas: amountGazProvided
        })
        .then(instance => {
          aRLCInstance = instance;
          return aRLCInstance.unlock({
            from: rlcCreator,
            gas: amountGazProvided
          });
        })
        .then(txMined => {
          assert.isBelow(txMined.receipt.gasUsed, amountGazProvided, "should not use all gas");
          return IexecOracleEscrow.new(aRLCInstance.address, {
            from: bridge
          });
        })
        .then(instance => {
          aIexecOracleEscrowInstance = instance;
          return IexecOracle.new(aIexecOracleEscrowInstance.address, 0, {
            from: bridge
          });
        })
        .then(instance => {
          aIexecOracleInstance = instance;
          return IexecOracleAPI.new(aIexecOracleInstance.address, 1, "aDappName", {
            from: provider
          });
        })
        .then(instance => {
          aIexecOracleAPI = instance;
        });
    });


    it("Test dapp price are set correctly in IexecOracle", function() {
      this.timeout(testTimemout);
      return aIexecOracleInstance.getDappPrice.call(aIexecOracleAPI.address)
        .then(priceStored => {
          assert.strictEqual(1, priceStored.toNumber(), "1 priceStored");
        });
    });

  });




  describe("Test provider, dapp (1 RLC cost and 0,002 ether for callback) registration In IexecOracle", function() {
    let aIexecOracleInstance;
    let aIexecOracleAPI;
    let aRLCInstance;
    let aIexecOracleEscrowInstance;
    let previousBlockNumber;
    let callbackPrice = web3.toWei('0.002', 'ether');
    beforeEach("create a new contract instance", function() {
      return RLC.new({
          from: rlcCreator,
          gas: amountGazProvided
        })
        .then(instance => {
          aRLCInstance = instance;
          return aRLCInstance.unlock({
            from: rlcCreator,
            gas: amountGazProvided
          });
        })
        .then(txMined => {
          assert.isBelow(txMined.receipt.gasUsed, amountGazProvided, "should not use all gas");
          return IexecOracleEscrow.new(aRLCInstance.address, {
            from: bridge
          });
        })
        .then(instance => {
          aIexecOracleEscrowInstance = instance;
          return IexecOracle.new(aIexecOracleEscrowInstance.address, callbackPrice, {
            from: bridge
          });
        })
        .then(instance => {
          aIexecOracleInstance = instance;
          return IexecOracleAPI.new(aIexecOracleInstance.address, 1, "aDappName", {
            from: provider
          });
        })
        .then(instance => {
          aIexecOracleAPI = instance;
        });
    });


    it("Test callback price are set correctly in IexecOracle", function() {
      this.timeout(testTimemout);
      return aIexecOracleInstance.callbackPrice.call()
        .then(priceStored => {
          assert.strictEqual(priceStored.toString(10), callbackPrice.toString(10), "0.002 ether");
        });
    });

  });




  describe("Test free submit fonction on IexecOracle well initialized", function() {
    let aIexecOracleInstance;
    let aIexecOracleAPI;
    let aRLCInstance;
    let aIexecOracleEscrowInstance;
    beforeEach("create a new contract instance", function() {
      return RLC.new({
          from: rlcCreator,
          gas: amountGazProvided
        })
        .then(instance => {
          aRLCInstance = instance;
          return aRLCInstance.unlock({
            from: rlcCreator,
            gas: amountGazProvided
          });
        })
        .then(txMined => {
          assert.isBelow(txMined.receipt.gasUsed, amountGazProvided, "should not use all gas");
          return IexecOracleEscrow.new(aRLCInstance.address, {
            from: bridge
          });
        })
        .then(instance => {
          aIexecOracleEscrowInstance = instance;
          return IexecOracle.new(aIexecOracleEscrowInstance.address, 0, {
            from: bridge
          });
        })
        .then(instance => {
          aIexecOracleInstance = instance;
          return IexecOracleAPI.new(aIexecOracleInstance.address, 0, "aDappName", {
            from: provider
          });
        })
        .then(instance => {
          aIexecOracleAPI = instance;
        });
    });

    it("Test free Submit Event when call iexecSubmit", function() {
      this.timeout(testTimemout);
      let previousBlockNumber;
      let submitTxHash;
      return Extensions.getCurrentBlockNumber()
        .then(block => {
          previousBlockNumber = block;
          return aIexecOracleAPI.iexecSubmit("-lrt", {
            from: user,
            gas: amountGazProvided
          });
        })
        .then(txMined => {
          submitTxHash = txMined.tx;
          assert.isBelow(txMined.receipt.gasUsed, amountGazProvided, "should not use all gas");
          return Extensions.getEventsPromise(aIexecOracleInstance.Submit({}, {
            fromBlock: previousBlockNumber
          }));
        })
        .then(events => {
          assert.strictEqual(events[0].args.user, user, "user");
          assert.strictEqual(events[0].args.dapp, aIexecOracleAPI.address, "dapp");
          assert.strictEqual(events[0].args.provider, provider, "provider");
          assert.strictEqual(events[0].args.args, "-lrt", "args");
        });
    });


    it("Test Circuit Breakers when active ", function() {
      return aIexecOracleAPI.iexecSubmit("-lrt", {
          from: user,
          gas: amountGazProvided
        })
        .then(txMined => {
          assert.isBelow(txMined.receipt.gasUsed, amountGazProvided, "should not use all gas");
          return aIexecOracleInstance.stopped.call();
        })
        .then(stoppedCall => {
          assert.isFalse(stoppedCall, "contract is not stopped");
          return aIexecOracleInstance.toggleContractActive({
            from: bridge,
            gas: amountGazProvided
          });
        })
        .then(txMined => {
          assert.isBelow(txMined.receipt.gasUsed, amountGazProvided, "should not use all gas");
          return aIexecOracleInstance.stopped.call();
        })
        .then(stoppedCall => {
          assert.isTrue(stoppedCall, "contract is stopped");
          return Extensions.expectedExceptionPromise(() => {
            return aIexecOracleAPI.iexecSubmit("-lrt", {
                from: user,
                gas: amountGazProvided
              });
            },
            amountGazProvided);
        })
        .then(() => {
          return aIexecOracleInstance.toggleContractActive({
            from: bridge,
            gas: amountGazProvided
          });
        })
        .then(txMined => {
          assert.isBelow(txMined.receipt.gasUsed, amountGazProvided, "should not use all gas");
          return aIexecOracleInstance.stopped.call();
        })
        .then(stoppedCall => {
          assert.isFalse(stoppedCall, "contract is active again");
          return aIexecOracleAPI.iexecSubmit("-lrt", {
              from: user,
              gas: amountGazProvided
            });
        })
        .then(txMined => {
          assert.isBelow(txMined.receipt.gasUsed, amountGazProvided, "should not use all gas");
          return aIexecOracleInstance.toggleContractActive({
            from: user,
            gas: amountGazProvided
          });
        })
        .then(() => aIexecOracleInstance.stopped.call())
        .then(stoppedCall => assert.isFalse(stoppedCall, "contract is active again. user can't change toggle"));
    });

  });


  describe("Test 2 RLC cost with no callback price submit fonction on IexecOracle well initialized", function() {
    let aIexecOracleInstance;
    let aIexecOracleAPI;
    let aRLCInstance;
    let aIexecOracleEscrowInstance;
    beforeEach("create a new contract instance", function() {
      return RLC.new({
          from: rlcCreator,
          gas: amountGazProvided
        })
        .then(instance => {
          aRLCInstance = instance;
          return aRLCInstance.unlock({
            from: rlcCreator,
            gas: amountGazProvided
          });
        })
        .then(txMined => {
          assert.isBelow(txMined.receipt.gasUsed, amountGazProvided, "should not use all gas");
          return IexecOracleEscrow.new(aRLCInstance.address, {
            from: bridge
          });
        })
        .then(instance => {
          aIexecOracleEscrowInstance = instance;
          return IexecOracle.new(aIexecOracleEscrowInstance.address, 0, {
            from: bridge
          });
        })
        .then(instance => {
          aIexecOracleInstance = instance;
          return IexecOracleAPI.new(aIexecOracleInstance.address, 2, "aDappName", {
            from: provider
          });
        })
        .then(instance => {
          aIexecOracleAPI = instance;
          return aIexecOracleEscrowInstance.changeIexecOracleRegistrationStatus(aIexecOracleInstance.address, true, {
            from: bridge,
            gas: amountGazProvided
          });
        })
        .then(txMined => {
          assert.isBelow(txMined.receipt.gasUsed, amountGazProvided, "should not use all gas");
        });
    });


    it("Test 2 RLC cost Submit Event when call iexecSubmit OK if user has allowed 2 RLC and have 2 RLC ", function() {
      this.timeout(testTimemout);
      let previousBlockNumber;
      let submitTxHash;
      return aRLCInstance.transfer(user, 2, {
          from: rlcCreator,
          gas: amountGazProvided
        })
        .then(txMined => {
          assert.isBelow(txMined.receipt.gasUsed, amountGazProvided, "should not use all gas");
          return aRLCInstance.approve(aIexecOracleEscrowInstance.address, 2, {
            from: user,
            gas: amountGazProvided
          })
        })
        .then(txMined => {
          assert.isBelow(txMined.receipt.gasUsed, amountGazProvided, "should not use all gas");
          return Extensions.getCurrentBlockNumber();
        })
        .then(block => {
          previousBlockNumber = block;
          return aIexecOracleAPI.iexecSubmit("-lrt", {
            from: user,
            gas: amountGazProvided
          });
        })
        .then(txMined => {
          submitTxHash = txMined.tx;
          assert.isBelow(txMined.receipt.gasUsed, amountGazProvided, "should not use all gas");
          return Extensions.getEventsPromise(aIexecOracleInstance.Submit({}, {
            fromBlock: previousBlockNumber
          }));
        })
        .then(events => {
          assert.strictEqual(events[0].args.user, user, "user");
          assert.strictEqual(events[0].args.dapp, aIexecOracleAPI.address, "dapp");
          assert.strictEqual(events[0].args.provider, provider, "provider");
          assert.strictEqual(events[0].args.args, "-lrt", "args");
          return Extensions.getEventsPromise(aRLCInstance.Transfer({}, {
            fromBlock: previousBlockNumber
          }));
        })
        .then(events => {
          assert.strictEqual(events[0].args.from, user, "user");
          assert.strictEqual(events[0].args.to, aIexecOracleEscrowInstance.address, "  aIexecOracleEscrowInstance receive 2 RLC deposit");
          assert.strictEqual(events[0].args.value.toNumber(), 2, "2 RLC");
        });
    });


    it("Test 2 RLC cost Submit Event when call iexecSubmit ko if user has 2 RLC but not allowed 2 RLC", function() {
      this.timeout(testTimemout);
      return aRLCInstance.transfer(user, 2, {
          from: rlcCreator,
          gas: amountGazProvided
        })
        .then(txMined => {
          assert.isBelow(txMined.receipt.gasUsed, amountGazProvided, "should not use all gas");
          return Extensions.expectedExceptionPromise(() => {
              return aIexecOracleAPI.iexecSubmit("-lrt", {
                from: user,
                gas: amountGazProvided
              });
            },
            amountGazProvided);
        });
    });

    it("Test 2 RLC cost Submit Event when call iexecSubmit ko if user has allowed 2 RLC but have no 2 RLC", function() {
      this.timeout(testTimemout);
      return aRLCInstance.approve(aIexecOracleEscrowInstance.address, 2, {
          from: user,
          gas: amountGazProvided
        })
        .then(txMined => {
          assert.isBelow(txMined.receipt.gasUsed, amountGazProvided, "should not use all gas");
          return Extensions.expectedExceptionPromise(() => {
              return aIexecOracleAPI.iexecSubmit("-lrt", {
                from: user,
                gas: amountGazProvided
              });
            },
            amountGazProvided);
        });
    });

    it("Test 2 RLC cost Submit Event when call iexecSubmit KO if user has allowed 1 RLC and have 2 RLC", function() {
      this.timeout(testTimemout);
      let previousBlockNumber;
      let submitTxHash;
      return aRLCInstance.transfer(user, 2, {
          from: rlcCreator,
          gas: amountGazProvided
        })
        .then(txMined => {
          assert.isBelow(txMined.receipt.gasUsed, amountGazProvided, "should not use all gas");
          return aRLCInstance.approve(aIexecOracleEscrowInstance.address, 1, {
            from: user,
            gas: amountGazProvided
          })
        })
        .then(txMined => {
          assert.isBelow(txMined.receipt.gasUsed, amountGazProvided, "should not use all gas");
          return Extensions.expectedExceptionPromise(() => {
              return aIexecOracleAPI.iexecSubmit("-lrt", {
                from: user,
                gas: amountGazProvided
              });
            },
            amountGazProvided);
        });
    });


  });



  describe("Test 2 RLC cost with no callback price submit fonction on IexecOracle not initialized because missing IexecOracleEscrowRegistration", function() {
    let aIexecOracleInstance;
    let aIexecOracleAPI;
    let aRLCInstance;
    let aIexecOracleEscrowInstance;
    beforeEach("create a new contract instance", function() {
      return RLC.new({
          from: rlcCreator,
          gas: amountGazProvided
        })
        .then(instance => {
          aRLCInstance = instance;
          return aRLCInstance.unlock({
            from: rlcCreator,
            gas: amountGazProvided
          });
        })
        .then(txMined => {
          assert.isBelow(txMined.receipt.gasUsed, amountGazProvided, "should not use all gas");
          return IexecOracleEscrow.new(aRLCInstance.address, {
            from: bridge
          });
        })
        .then(instance => {
          aIexecOracleEscrowInstance = instance;
          return IexecOracle.new(aIexecOracleEscrowInstance.address, 0, {
            from: bridge
          });
        })
        .then(instance => {
          aIexecOracleInstance = instance;
          return IexecOracleAPI.new(aIexecOracleInstance.address, 2, "aDappName", {
            from: provider
          });
        })
        .then(instance => {
          aIexecOracleAPI = instance;
        });
    });

    it("Test 2 RLC cost Submit Event when call iexecSubmit OK if user has allowed 2 RLC and have 2 RLC on IexecOracle not initialized because missing IexecOracleEscrowRegistration", function() {
      this.timeout(testTimemout);
      let previousBlockNumber;
      let submitTxHash;
      return aRLCInstance.transfer(user, 2, {
          from: rlcCreator,
          gas: amountGazProvided
        })
        .then(txMined => {
          assert.isBelow(txMined.receipt.gasUsed, amountGazProvided, "should not use all gas");
          return aRLCInstance.approve(aIexecOracleEscrowInstance.address, 2, {
            from: user,
            gas: amountGazProvided
          })
        })
        .then(txMined => {
          assert.isBelow(txMined.receipt.gasUsed, amountGazProvided, "should not use all gas");
          return Extensions.expectedExceptionPromise(() => {
              return aIexecOracleAPI.iexecSubmit("-lrt", {
                from: user,
                gas: amountGazProvided
              });
            },
            amountGazProvided);
        });

    });

  });




  describe("Test submit fonction on IexecOracle not initialized", function() {
    let aIexecOracleInstance;
    let aIexecOracleAPI;
    let aRLCInstance;
    let aIexecOracleEscrowInstance;
    beforeEach("create a new contract instance", function() {
      return RLC.new({
          from: rlcCreator,
          gas: amountGazProvided
        })
        .then(instance => {
          aRLCInstance = instance;
          return aRLCInstance.unlock({
            from: rlcCreator,
            gas: amountGazProvided
          });
        })
        .then(txMined => {
          assert.isBelow(txMined.receipt.gasUsed, amountGazProvided, "should not use all gas");
          return IexecOracleEscrow.new(aRLCInstance.address, {
            from: bridge
          });
        })
        .then(instance => {
          aIexecOracleEscrowInstance = instance;
          return IexecOracle.new(aIexecOracleEscrowInstance.address, 0, {
            from: bridge
          });
        })
        .then(instance => {
          aIexecOracleInstance = instance;
          return IexecOracleAPIUnregistered.new(aIexecOracleInstance.address, 0, "dappName", {
            from: provider
          });
        })
        .then(instance => {
          aIexecOracleAPI = instance;
        });
    });

    it("Test iexecSubmit on a unregister smart contract provider must failed. (modifier check onlyRegistered )  ", function() {
      this.timeout(testTimemout);
      return Extensions.expectedExceptionPromise(() => {
          return aIexecOracleAPI.iexecSubmit("-lrt", {
            from: user,
            gas: amountGazProvided
          });
        },
        amountGazProvided);
    });

  });


  describe("Test submit fonction on IexecOracle initialized with a gas calback price to pay", function() {
    let aIexecOracleInstance;
    let aIexecOracleAPI;
    let aRLCInstance;
    let aIexecOracleEscrowInstance;
    let callbackPrice = web3.toWei('0.002', 'ether');
    beforeEach("create a new contract instance", function() {
      return RLC.new({
          from: rlcCreator,
          gas: amountGazProvided
        })
        .then(instance => {
          aRLCInstance = instance;
          return aRLCInstance.unlock({
            from: rlcCreator,
            gas: amountGazProvided
          });
        })
        .then(txMined => {
          assert.isBelow(txMined.receipt.gasUsed, amountGazProvided, "should not use all gas");
          return IexecOracleEscrow.new(aRLCInstance.address, {
            from: bridge
          });
        })
        .then(instance => {
          aIexecOracleEscrowInstance = instance;
          return IexecOracle.new(aIexecOracleEscrowInstance.address, callbackPrice, {
            from: bridge
          });
        })
        .then(instance => {
          aIexecOracleInstance = instance;
          return IexecOracleAPI.new(aIexecOracleInstance.address, 0, "aDappName", {
            from: provider
          });
        })
        .then(instance => {
          aIexecOracleAPI = instance;
        });
    });

    it("Test iexecSubmit with enough ether for the callback gas pay", function() {
      this.timeout(testTimemout);
      return aIexecOracleAPI.iexecSubmit("-lrt", {
          from: user,
          gas: amountGazProvided,
          value: web3.toWei('0.002', 'ether')
        })
        .then(txMined => {
          submitTxHash = txMined.tx;
          assert.isBelow(txMined.receipt.gasUsed, amountGazProvided, "should not use all gas");
        });
    });

    it("Test iexecSubmit with not enough ether", function() {
      this.timeout(testTimemout);
      return Extensions.expectedExceptionPromise(() => {
          return aIexecOracleAPI.iexecSubmit("-lrt", {
            from: user,
            gas: amountGazProvided,
            value: web3.toWei('0.001', 'ether')
          });
        },
        amountGazProvided);
    });

    it("Test iexecSubmit with too much ether", function() {
      this.timeout(testTimemout);
      return Extensions.expectedExceptionPromise(() => {
          return aIexecOracleAPI.iexecSubmit("-lrt", {
            from: user,
            gas: amountGazProvided,
            value: web3.toWei('1', 'ether')
          });
        },
        amountGazProvided);
    });

    it("Test iexecSubmit after price change to 0.001 ether ", function() {
      this.timeout(testTimemout);
      return aIexecOracleInstance.changeCallbackPrice(web3.toWei('0.001', 'ether'), {
          from: bridge,
          gas: amountGazProvided,
        })
        .then(txMined => {
          assert.isBelow(txMined.receipt.gasUsed, amountGazProvided, "should not use all gas");
          return aIexecOracleAPI.iexecSubmit("-lrt", {
            from: user,
            gas: amountGazProvided,
            value: web3.toWei('0.001', 'ether')
          });
        })
        .then(txMined => {
          submitTxHash = txMined.tx;
          assert.isBelow(txMined.receipt.gasUsed, amountGazProvided, "should not use all gas");
        });
    });

    it("Test iexecSubmit user cant't change the price", function() {
      this.timeout(testTimemout);
      return Extensions.expectedExceptionPromise(() => {
          return aIexecOracleInstance.changeCallbackPrice(web3.toWei('0.001', 'ether'), {
            from: user,
            gas: amountGazProvided,
          });
        },
        amountGazProvided);
    });

    it("Test admin received the eth callback price for pay the callback tx", function() {
      this.timeout(testTimemout);
      var initialBridgeBalance;
      return web3.eth.getBalancePromise(bridge)
        .then(balance => {
          initialBridgeBalance = balance;
          return aIexecOracleAPI.iexecSubmit("-lrt", {
            from: user,
            gas: amountGazProvided,
            value: web3.toWei('0.002', 'ether')
          });
        })
        .then(txMined => {
          assert.isBelow(txMined.receipt.gasUsed, amountGazProvided, "should not use all gas");
          return web3.eth.getBalancePromise(bridge);
        })
        .then(balance => {
          assert.strictEqual(balance.minus(web3.toWei('0.002', 'ether')).toString(10), initialBridgeBalance.toString(10), "bridge received 0.002 ether");
        });
    });

  });

  describe("Test free Submit function call then simulate bridge response", function() {
    let aIexecOracleInstance;
    let aIexecOracleAPI;
    let aRLCInstance;
    let aIexecOracleEscrowInstance;
    let submitTxHash;
    beforeEach("create a new contract instance and call Submit ls", function() {
      return RLC.new({
          from: rlcCreator,
          gas: amountGazProvided
        })
        .then(instance => {
          aRLCInstance = instance;
          return aRLCInstance.unlock({
            from: rlcCreator,
            gas: amountGazProvided
          });
        })
        .then(txMined => {
          assert.isBelow(txMined.receipt.gasUsed, amountGazProvided, "should not use all gas");
          return IexecOracleEscrow.new(aRLCInstance.address, {
            from: bridge
          });
        })
        .then(instance => {
          aIexecOracleEscrowInstance = instance;
          return IexecOracle.new(aIexecOracleEscrowInstance.address, 0, {
            from: bridge
          });
        })
        .then(instance => {
          aIexecOracleInstance = instance;
          return IexecOracleAPI.new(aIexecOracleInstance.address, 0, "aDappName", {
            from: provider
          });
        })
        .then(instance => {
          aIexecOracleAPI = instance;
          return aIexecOracleAPI.iexecSubmit("-lrt", {
            from: user,
            gas: amountGazProvided
          });
        })
        .then(txMined => {
          submitTxHash = txMined.tx;
          assert.isBelow(txMined.receipt.gasUsed, amountGazProvided, "should not use all gas");
        });
    });

    it("Only bridge can call SubmitCallback function", function() {
      this.timeout(testTimemout);
      return Extensions.expectedExceptionPromise(() => {
          return aIexecOracleInstance.submitCallback(submitTxHash, user, aIexecOracleAPI.address /*=>dapp*/ , IexecOracle.Status.COMPLETED, "stdout", "", "uri_here",{
            from: user,
            gas: amountGazProvided
          });
        },
        amountGazProvided);
    });


    it("Simulate bridge response OK and test event Submit", function() {
      this.timeout(testTimemout);
      //simulate bridge response
      let previousBlockNumber;
      let previousBlockTime;
      let workTimestamp;
      let nextBlockTime;
      return Promise.all([
          Extensions.getCurrentBlockTime(),
          Extensions.getCurrentBlockNumber()
        ])
        .then(now => {
          previousBlockTime = now[0];
          previousBlockNumber = now[1];
          return aIexecOracleInstance.submitCallback(submitTxHash, user, aIexecOracleAPI.address /*=>dapp*/ , IexecOracle.Status.COMPLETED, "stdout", "", "uri_here",{
            from: bridge,
            gas: amountGazProvided
          });
        })
        .then(txMined => {
          assert.isBelow(txMined.receipt.gasUsed, amountGazProvided, "should not use all gas");
          assert.strictEqual(txMined.logs[0].event, "SubmitCallback", "event");
          assert.strictEqual(txMined.logs[0].args.submitTxHash, submitTxHash, "submitTxHash");
          assert.strictEqual(txMined.logs[0].args.user, user, "user");
          assert.strictEqual(txMined.logs[0].args.stdout, "stdout", "stdout");
          assert.strictEqual(txMined.logs[0].args.uri, "uri_here", "uri");
          return Promise.all([
            aIexecOracleInstance.getWork.call(txMined.logs[0].args.submitTxHash),
            Extensions.getCurrentBlockTime()
          ]);
        })
        .then(workAndNow => {
          [timestamp, status, stdout, stderr, uri] = workAndNow[0];
          nextBlockTime = workAndNow[1];
          workTimestamp = timestamp.toNumber();
          assert.isAtLeast(workTimestamp, previousBlockTime, "work timestamp >= previousBlockTime");
          assert.isAtLeast(nextBlockTime, workTimestamp, "work timestamp <= nextBlockTime");
          assert.strictEqual(status.toNumber(), IexecOracle.Status.COMPLETED, "work status");
          assert.strictEqual(stdout, "stdout", "work stdout");
          assert.strictEqual(stderr, "", "work stderr");
          assert.strictEqual(uri, "uri_here", "work uri");
          return Extensions.getEventsPromise(aIexecOracleAPI.IexecSubmitCallback({}, {
            fromBlock: previousBlockNumber
          }));
        })
        .then(events => {
          assert.strictEqual(events[0].args.submitTxHash, submitTxHash, "submitTxHash");
          assert.strictEqual(events[0].args.user, user, "user");
          assert.strictEqual(events[0].args.stdout, "stdout", "stdout");
          assert.strictEqual(events[0].args.uri, "uri_here", "uri");
        });
    });

    it("Simulate bridge response KO and test event Submit", function() {
      this.timeout(testTimemout);
      let previousBlockTime;
      let workTimestamp;
      let nextBlockTime;
      //simulate bridge response
      return Promise.all([
          Extensions.getCurrentBlockTime(),
          Extensions.getCurrentBlockNumber()
        ])
        .then(now => {
          previousBlockTime = now[0];
          previousBlockNumber = now[1];
          return aIexecOracleInstance.submitCallback(submitTxHash, user, aIexecOracleAPI.address /*=>dapp*/ , IexecOracle.Status.ERROR, "stdout", "bridge crash","uri_here", {
            from: bridge,
            gas: amountGazProvided
          });
        })
        .then(txMined => {
          assert.isBelow(txMined.receipt.gasUsed, amountGazProvided, "should not use all gas");
          assert.strictEqual(txMined.logs[0].event, "SubmitCallback", "event");
          assert.strictEqual(txMined.logs[0].args.submitTxHash, submitTxHash, "submitTxHash");
          assert.strictEqual(txMined.logs[0].args.user, user, "user");
          assert.strictEqual(txMined.logs[0].args.stdout, "stdout", "stdout");
          assert.strictEqual(txMined.logs[0].args.uri, "uri_here", "uri");
          return Promise.all([
            aIexecOracleInstance.getWork.call(txMined.logs[0].args.submitTxHash),
            Extensions.getCurrentBlockTime()
          ]);
        })
        .then(workAndNow => {
          [timestamp, status, stdout, stderr, uri] = workAndNow[0];
          nextBlockTime = workAndNow[1];
          workTimestamp = timestamp.toNumber();
          assert.isAtLeast(workTimestamp, previousBlockTime, "work timestamp >= previousBlockTime");
          assert.isAtLeast(nextBlockTime, workTimestamp, "work timestamp <= nextBlockTime");
          assert.strictEqual(status.toNumber(), IexecOracle.Status.ERROR, "work status");
          assert.strictEqual(stdout, "stdout", "work stdout");
          assert.strictEqual(stderr, "bridge crash", "work stderr");
          assert.strictEqual(uri, "uri_here", "work uri");
          return Extensions.getEventsPromise(aIexecOracleAPI.IexecSubmitCallback({}, {
            fromBlock: previousBlockNumber
          }));
        })
        .then(events => {
          assert.strictEqual(events[0].args.submitTxHash, submitTxHash, "submitTxHash");
          assert.strictEqual(events[0].args.user, user, "user");
          assert.strictEqual(events[0].args.stdout, "stdout", "stdout");
          assert.strictEqual(events[0].args.uri, "uri_here", "uri");
        });
    });

    it(" bridge can't call with status UNSET", function() {
      this.timeout(testTimemout);
      return Extensions.expectedExceptionPromise(() => {
          return aIexecOracleInstance.submitCallback(submitTxHash, user, aIexecOracleAPI.address /*=>dapp*/ , IexecOracle.Status.UNSET, "stdout", "", "uri_here", {
            from: bridge,
            gas: amountGazProvided
          });
        },
        amountGazProvided);
    });

    it("bridge can't call twice on the same submitTxHash", function() {
      this.timeout(testTimemout);
      return aIexecOracleInstance.submitCallback(submitTxHash, user, aIexecOracleAPI.address /*=>dapp*/ , IexecOracle.Status.ERROR, "stdout", "bridge crash", "uri_here", {
          from: bridge,
          gas: amountGazProvided
        })
        .then(txMined => {
          assert.isBelow(txMined.receipt.gasUsed, amountGazProvided, "should not use all gas");
          return Extensions.expectedExceptionPromise(() => {
              return aIexecOracleInstance.submitCallback(submitTxHash, user, aIexecOracleAPI.address /*=>dapp*/ , IexecOracle.Status.COMPLETED, "stdout", "", "uri_here", {
                from: bridge,
                gas: amountGazProvided
              });
            },
            amountGazProvided
          );
        });
    });
  });



  describe("Test 1 RLC dapp Submit function call then simulate bridge response", function() {

    let aIexecOracleInstance;
    let aIexecOracleAPI;
    let aRLCInstance;
    let aIexecOracleEscrowInstance;
    let previousBlockNumber;
    let submitTxHash;
    beforeEach("create a new contract instance and call Submit ls", function() {
      return RLC.new({
          from: rlcCreator,
          gas: amountGazProvided
        })
        .then(instance => {
          aRLCInstance = instance;
          return aRLCInstance.unlock({
            from: rlcCreator,
            gas: amountGazProvided
          });
        })
        .then(txMined => {
          assert.isBelow(txMined.receipt.gasUsed, amountGazProvided, "should not use all gas");
          return IexecOracleEscrow.new(aRLCInstance.address, {
            from: bridge
          });
        })
        .then(instance => {
          aIexecOracleEscrowInstance = instance;
          return IexecOracle.new(aIexecOracleEscrowInstance.address, 0, {
            from: bridge
          });
        })
        .then(instance => {
          aIexecOracleInstance = instance;
          return IexecOracleAPI.new(aIexecOracleInstance.address, 1, "aDappName", {
            from: provider
          });
        })
        .then(instance => {
          aIexecOracleAPI = instance;
          return aRLCInstance.transfer(user, 1, {
            from: rlcCreator,
            gas: amountGazProvided
          });
        })
        .then(txMined => {
          assert.isBelow(txMined.receipt.gasUsed, amountGazProvided, "should not use all gas");
          return aRLCInstance.approve(aIexecOracleEscrowInstance.address, 1, {
            from: user,
            gas: amountGazProvided
          })
        })
        .then(txMined => {
          assert.isBelow(txMined.receipt.gasUsed, amountGazProvided, "should not use all gas");
          return aIexecOracleEscrowInstance.changeIexecOracleRegistrationStatus(aIexecOracleInstance.address, true, {
            from: bridge,
            gas: amountGazProvided
          });
        })
        .then(txMined => {
          assert.isBelow(txMined.receipt.gasUsed, amountGazProvided, "should not use all gas");
          return Promise.all([
            aRLCInstance.balanceOf.call(user),
            aRLCInstance.balanceOf.call(aIexecOracleEscrowInstance.address),
            aRLCInstance.balanceOf.call(provider)
          ]);
        })
        .then(balances => {
          assert.strictEqual(balances[0].toNumber(), 1, "user has 1 RLC. ready to use it for submit ");
          assert.strictEqual(balances[1].toNumber(), 0, "aIexecOracleEscrowInstance 0 RLC pending");
          assert.strictEqual(balances[2].toNumber(), 0, "provider has no RLC");
          return Extensions.getCurrentBlockNumber();
        })
        .then(block => {
          previousBlockNumber = block;
          return aIexecOracleAPI.iexecSubmit("-lrt", {
            from: user,
            gas: amountGazProvided
          });
        })
        .then(txMined => {
          submitTxHash = txMined.tx;
          assert.isBelow(txMined.receipt.gasUsed, amountGazProvided, "should not use all gas");
          return Extensions.getEventsPromise(aIexecOracleInstance.Submit({}, {
            fromBlock: previousBlockNumber
          }));
        })
        .then(events => {
          assert.strictEqual(events[0].args.user, user, "user");
          assert.strictEqual(events[0].args.dapp, aIexecOracleAPI.address, "dapp");
          assert.strictEqual(events[0].args.provider, provider, "provider");
          assert.strictEqual(events[0].args.args, "-lrt", "args");
          return Extensions.getEventsPromise(aRLCInstance.Transfer({}, {
            fromBlock: previousBlockNumber
          }));
        })
        .then(events => {
          assert.strictEqual(events[0].args.from, user, "user");
          assert.strictEqual(events[0].args.to, aIexecOracleEscrowInstance.address, "aIexecOracleEscrowInstance has receive 1 RLC deposit");
          assert.strictEqual(events[0].args.value.toNumber(), 1, "1 RLC");
        });
    });



    it("Simulate bridge response OK and test event Submit", function() {
      this.timeout(testTimemout);
      //simulate bridge response
      let previousBlockNumber;
      let previousBlockTime;
      let workTimestamp;
      let nextBlockTime;
      return Promise.all([
          aRLCInstance.balanceOf.call(user),
          aRLCInstance.balanceOf.call(aIexecOracleEscrowInstance.address),
          aRLCInstance.balanceOf.call(provider)
        ])
        .then(balances => {
          assert.strictEqual(balances[0].toNumber(), 0, "user 0 RLC has used 1 for submit ");
          assert.strictEqual(balances[1].toNumber(), 1, "aIexecOracleEscrowInstance 1 RLC pending comming from user 1");
          assert.strictEqual(balances[2].toNumber(), 0, "provider has no RLC");
          return Promise.all([
            Extensions.getCurrentBlockTime(),
            Extensions.getCurrentBlockNumber()
          ]);
        })
        .then(now => {
          previousBlockTime = now[0];
          previousBlockNumber = now[1];
          return aIexecOracleInstance.submitCallback(submitTxHash, user, aIexecOracleAPI.address /*=>dapp*/ , IexecOracle.Status.COMPLETED, "stdout", "", "uri_here",{
            from: bridge,
            gas: amountGazProvided
          });
        })
        .then(txMined => {
          assert.isBelow(txMined.receipt.gasUsed, amountGazProvided, "should not use all gas");
          assert.strictEqual(txMined.logs[0].event, "SubmitCallback", "event");
          assert.strictEqual(txMined.logs[0].args.submitTxHash, submitTxHash, "submitTxHash");
          assert.strictEqual(txMined.logs[0].args.user, user, "user");
          assert.strictEqual(txMined.logs[0].args.stdout, "stdout", "stdout");
          assert.strictEqual(txMined.logs[0].args.uri, "uri_here", "uri");
          return Promise.all([
            aIexecOracleInstance.getWork.call(txMined.logs[0].args.submitTxHash),
            Extensions.getCurrentBlockTime()
          ]);
        })
        .then(workAndNow => {
          [timestamp, status, stdout, stderr, uri] = workAndNow[0];
          nextBlockTime = workAndNow[1];
          workTimestamp = timestamp.toNumber();
          assert.isAtLeast(workTimestamp, previousBlockTime, "work timestamp >= previousBlockTime");
          assert.isAtLeast(nextBlockTime, workTimestamp, "work timestamp <= nextBlockTime");
          assert.strictEqual(status.toNumber(), IexecOracle.Status.COMPLETED, "work status");
          assert.strictEqual(stdout, "stdout", "work stdout");
          assert.strictEqual(stderr, "", "work stderr");
          assert.strictEqual(uri, "uri_here", "work uri");
          return Extensions.getEventsPromise(aIexecOracleAPI.IexecSubmitCallback({}, {
            fromBlock: previousBlockNumber
          }));
        })
        .then(events => {
          assert.strictEqual(events[0].args.submitTxHash, submitTxHash, "submitTxHash");
          assert.strictEqual(events[0].args.user, user, "user");
          assert.strictEqual(events[0].args.stdout, "stdout", "stdout");
          assert.strictEqual(events[0].args.uri, "uri_here", "uri");
          return Promise.all([
            aRLCInstance.balanceOf.call(user),
            aRLCInstance.balanceOf.call(aIexecOracleEscrowInstance.address),
            aRLCInstance.balanceOf.call(provider)
          ]);
        })
        .then(balances => {
          assert.strictEqual(balances[0].toNumber(), 0, "user 0 RLC");
          assert.strictEqual(balances[1].toNumber(), 0, "aIexecOracleEscrowInstance has now 0 RLC");
          assert.strictEqual(balances[2].toNumber(), 1, "provider should have receive 1 RLC");
        });
    });

    it("Simulate bridge response KO and test event Submit", function() {
      this.timeout(testTimemout);
      let previousBlockTime;
      let workTimestamp;
      let nextBlockTime;
      //simulate bridge response
      return Promise.all([
          aRLCInstance.balanceOf.call(user),
          aRLCInstance.balanceOf.call(aIexecOracleEscrowInstance.address),
          aRLCInstance.balanceOf.call(provider)
        ])
        .then(balances => {
          assert.strictEqual(balances[0].toNumber(), 0, "user 0 RLC has used 1 for submit ");
          assert.strictEqual(balances[1].toNumber(), 1, "aIexecOracleEscrowInstance 1 RLC pending comming from user 1");
          assert.strictEqual(balances[2].toNumber(), 0, "provider has no RLC");
          return Promise.all([
            Extensions.getCurrentBlockTime(),
            Extensions.getCurrentBlockNumber()
          ]);
        })
        .then(now => {
          previousBlockTime = now[0];
          previousBlockNumber = now[1];
          return aIexecOracleInstance.submitCallback(submitTxHash, user, aIexecOracleAPI.address /*=>dapp*/ , IexecOracle.Status.ERROR, "stdout", "bridge crash", "uri_here", {
            from: bridge,
            gas: amountGazProvided
          });
        })
        .then(txMined => {
          assert.isBelow(txMined.receipt.gasUsed, amountGazProvided, "should not use all gas");
          assert.strictEqual(txMined.logs[0].event, "SubmitCallback", "event");
          assert.strictEqual(txMined.logs[0].args.submitTxHash, submitTxHash, "submitTxHash");
          assert.strictEqual(txMined.logs[0].args.user, user, "user");
          assert.strictEqual(txMined.logs[0].args.stdout, "stdout", "stdout");
          assert.strictEqual(txMined.logs[0].args.uri, "uri_here", "uri");
          return Promise.all([
            aIexecOracleInstance.getWork.call(txMined.logs[0].args.submitTxHash),
            Extensions.getCurrentBlockTime()
          ]);
        })
        .then(workAndNow => {
          [timestamp, status, stdout, stderr, uri] = workAndNow[0];
          nextBlockTime = workAndNow[1];
          workTimestamp = timestamp.toNumber();
          assert.isAtLeast(workTimestamp, previousBlockTime, "work timestamp >= previousBlockTime");
          assert.isAtLeast(nextBlockTime, workTimestamp, "work timestamp <= nextBlockTime");
          assert.strictEqual(status.toNumber(), IexecOracle.Status.ERROR, "work status");
          assert.strictEqual(stdout, "stdout", "work stdout");
          assert.strictEqual(stderr, "bridge crash", "work stderr");
          assert.strictEqual(uri, "uri_here", "work uri");
          return Extensions.getEventsPromise(aIexecOracleAPI.IexecSubmitCallback({}, {
            fromBlock: previousBlockNumber
          }));
        })
        .then(events => {
          assert.strictEqual(events[0].args.submitTxHash, submitTxHash, "submitTxHash");
          assert.strictEqual(events[0].args.user, user, "user");
          assert.strictEqual(events[0].args.stdout, "stdout", "stdout");
          assert.strictEqual(events[0].args.uri, "uri_here", "uri");
          return Promise.all([
            aRLCInstance.balanceOf.call(user),
            aRLCInstance.balanceOf.call(aIexecOracleEscrowInstance.address),
            aRLCInstance.balanceOf.call(provider)
          ]);
        })
        .then(balances => {
          assert.strictEqual(balances[0].toNumber(), 1, "ERROR => 1 RLC  go back to user");
          assert.strictEqual(balances[1].toNumber(), 0, "aIexecOracleEscrowInstance has now 0 RLC");
          assert.strictEqual(balances[2].toNumber(), 0, "provider 0 RLC");
        });
    });


    it("SAV test: owner can unlock found, to pay back users with pending works never callback and RLC locked in aIexecOracleEscrowInstance", function() {
      return Promise.all([
          aRLCInstance.balanceOf.call(user),
          aRLCInstance.balanceOf.call(aIexecOracleEscrowInstance.address),
          aRLCInstance.balanceOf.call(provider)
        ])
        .then(balances => {
          assert.strictEqual(balances[0].toNumber(), 0, "user 0 RLC has used 1 for submit ");
          assert.strictEqual(balances[1].toNumber(), 1, "aIexecOracleEscrowInstance 1 RLC pending comming from user 1");
          assert.strictEqual(balances[2].toNumber(), 0, "provider has no RLC");
          return aIexecOracleEscrowInstance.rlcPayment(user, 1, {
              from: bridge,
              gas: amountGazProvided
            })
            .then(txMined => {
              assert.isBelow(txMined.receipt.gasUsed, amountGazProvided, "should not use all gas");
              return Promise.all([
                aRLCInstance.balanceOf.call(user),
                aRLCInstance.balanceOf.call(aIexecOracleEscrowInstance.address),
                aRLCInstance.balanceOf.call(provider)
              ]);
            })
            .then(balances => {
              assert.strictEqual(balances[0].toNumber(), 1, "ERROR => 1 RLC  go back to user");
              assert.strictEqual(balances[1].toNumber(), 0, "aIexecOracleEscrowInstance has now 0 RLC");
              assert.strictEqual(balances[2].toNumber(), 0, "provider 0 RLC");
            });
        });
    });



  });


});
